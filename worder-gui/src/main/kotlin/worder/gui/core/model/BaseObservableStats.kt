/**
 * Stamp was generated by <generateFileStamps.sh>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <BaseObservableStats.kt>
 * Created: <02/07/2020, 11:27:00 PM>
 * Modified: <04/08/2020, 07:11:08 PM>
 * Version: <18>
 */

package worder.gui.core.model

import javafx.beans.property.IntegerProperty
import javafx.beans.property.MapProperty
import javafx.beans.property.ReadOnlyMapProperty
import javafx.beans.property.SimpleMapProperty
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.launch
import tornadofx.getValue
import tornadofx.onChange
import worder.gui.tornadofx.observableMapOf
import kotlin.reflect.KProperty

open class BaseObservableStats(
        override val origin: String,
        titlesOrderPriority: List<String> = emptyList()
) : ObservableStats {
    private val titlesMapping: MutableMap<String, String> = mutableMapOf()

    private val mapProperty: MapProperty<String, Any?> = SimpleMapProperty(observableMapOf())
    private val map: MutableMap<String, Any?> by mapProperty

    private val titledMapProperty: MapProperty<String, Any?> = SimpleMapProperty(observableMapOf())
    private val titledMap: MutableMap<String, Any?> by titledMapProperty


    init {
        titlesOrderPriority.forEach {
            titledMap[it] = null
        }
    }


    /**
     * ObservableStats interface implementation
     */

    override val asMapProperty: ReadOnlyMapProperty<String, Any?> = mapProperty
    override val asMap: Map<String, Any?> = map
    override val asTitledMapProperty: ReadOnlyMapProperty<String, Any?> = titledMapProperty
    override val asTitledMap: Map<String, Any?> = titledMap


    /**
     * delegating itself.
     * these methods are called when a property is accessed.
     */

    @Suppress("UNCHECKED_CAST")
    operator fun <T : Any?> getValue(thisRef: Any?, property: KProperty<*>): T = map[property.name] as T

    operator fun <T : Any?> setValue(thisRef: Any?, property: KProperty<*>, value: T) = updatePropertyValue(property.name, value)


    /**
     * ways to register a new property and therefore provide delegate for.
     */

    fun bindThroughValue(
            initValue: Any?,
            title: String? = null
    ): ValueDelegate = ValueDelegate(initValue, title)

    fun bindThroughIntegerProperty(
            source: IntegerProperty,
            title: String? = null,
            usePropertyNameAsTitle: Boolean = true
    ): IntegerPropertyDelegate = IntegerPropertyDelegate(source, title, usePropertyNameAsTitle)


    /**
     * inner methods that abstract class work
     */

    private fun updatePropertyValue(propertyName: String, value: Any?) {
        val title: String = titlesMapping[propertyName]!!

        map[propertyName] = value
        titledMap[title] = value
    }

    private fun initPropertyTitle(propertyName: String, propertyTitle: String?): String {
        val newTitle: String = propertyTitle ?: titlesMapping[propertyName] ?: propertyName
        val currentMapping = titlesMapping.entries.find { it.value == newTitle }?.key

        // handling properties overriding and ensuring that new title is unique
        require(currentMapping == null || propertyName == currentMapping) {
            "Can't register new property! Property title [$newTitle] is already occupied! " +
                    "Current bound: [$newTitle -> $currentMapping] " +
                    "Proposed bound: [$newTitle -> $propertyName]"
        }

        titlesMapping[propertyName] = newTitle
        return newTitle
    }


    /**
     * BaseObservableStats is delegate by itself. All properties requests\accesses are proceeded with its getValue\setValue methods
     * Classes below are used for initial initialization of properties and some other stuff.
     */

    inner class ValueDelegate(
            private val initValue: Any?,
            private val propertyTitle: String?
    ) {
        operator fun provideDelegate(thisRef: Any?, property: KProperty<*>): BaseObservableStats {
            initPropertyTitle(property.name, propertyTitle)
            updatePropertyValue(property.name, initValue)
            return this@BaseObservableStats
        }
    }

    inner class IntegerPropertyDelegate(
            private val source: IntegerProperty,
            private val propertyTitle: String?,
            private val usePropertyNameAsTitle: Boolean
    ) {
        operator fun provideDelegate(thisRef: Any?, property: KProperty<*>): IntegerProperty {
            initPropertyTitle(
                    property.name,
                    if (usePropertyNameAsTitle && source.name.isNotBlank()) source.name else propertyTitle
            )

            updatePropertyValue(property.name, source.value)

            source.onChange {
                updatePropertyValue(property.name, it)
            }

            return source
        }
    }
}

/**
 * stats objects from the beginning were meant to be used in UI components.
 */

suspend inline fun <T : BaseObservableStats> T.applyWithMainUI(crossinline block: suspend T.() -> Unit): T {
    MainScope().launch {
        block.invoke(this@applyWithMainUI)
    }
    return this
}
