/**
 * Stamp was generated by <generateFileStamps.sh>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <WebsiteRequesterDecorator.kt>
 * Created: <02/07/2020, 11:27:00 PM>
 * Modified: <25/07/2020, 08:56:51 PM>
 * Version: <11>
 */

package worder.gui.update.model.impl

import javafx.beans.property.Property
import javafx.beans.property.SimpleBooleanProperty
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.future.await
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withTimeout
import tornadofx.getValue
import tornadofx.setValue
import worder.gui.core.model.BareWord
import worder.gui.update.model.DefinitionRequester
import worder.gui.update.model.ExampleRequester
import worder.gui.update.model.Requester
import worder.gui.update.model.TranscriptionRequester
import worder.gui.update.model.TranslationRequester
import java.io.IOException
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.util.concurrent.atomic.AtomicLong

/*
    Implements common behavior for website-based requester:
     * takes full responsibility of stats-keep
     * prevents a site from being requested too frequently
     * provides REQUEST_TIMEOUT and forces decorated object to stick to it
     * prevents requester.request() from being concurrently executed
 */

open class WebsiteRequesterDecorator(private val requester: Requester) : Requester {
    companion object {
        private const val REQUEST_INTERVAL = 3000L
        private const val REQUEST_TIMEOUT = 5000L

        private val client: HttpClient = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS).build()

        suspend fun sendGetRequest(url: String): String {
            val request = HttpRequest.newBuilder(URI.create(url)).build()
            val response = client.sendAsync(request, HttpResponse.BodyHandlers.ofString()).await()

            if (response.statusCode() != 200)
                throw IOException("HTTP request failed with code ${response.statusCode()}")

            return response.body()!!
        }
    }


    private var lastRequestTime = AtomicLong()
    private val mutex = Mutex()


    final override val isBusyProperty: Property<Boolean> = SimpleBooleanProperty(false)
    override var isBusy: Boolean by isBusyProperty
    override val observableStats: SimpleRequesterStats = SimpleRequesterStats(
            origin = requester.javaClass.simpleName.substringBefore("Requester"),
            totalRequests = 0,
            totalDefinitions = if (requester is DefinitionRequester) 0 else null,
            totalTranslations = if (requester is TranslationRequester) 0 else null,
            totalExamples = if (requester is ExampleRequester) 0 else null,
            totalTranscriptions = if (requester is TranscriptionRequester) 0 else null
    )


    override suspend fun requestWord(word: BareWord) {
        MainScope().launch { isBusy = true }

        mutex.withLock {
            (System.currentTimeMillis() - lastRequestTime.get()).let {
                if (it < REQUEST_INTERVAL)
                    delay(REQUEST_INTERVAL - it)
            }

            withTimeout(REQUEST_TIMEOUT) { requester.requestWord(word) }
        }

        lastRequestTime.set(System.currentTimeMillis())

        MainScope().launch {
            observableStats.apply {
                totalRequests++

                if (requester is DefinitionRequester)
                    totalDefinitions = totalDefinitions?.plus(requester.definitions.count())

                if (requester is TranslationRequester)
                    totalTranslations = totalTranslations?.plus(requester.translations.count())

                if (requester is ExampleRequester)
                    totalExamples = totalExamples?.plus(requester.examples.count())

                if (requester is TranscriptionRequester)
                    totalTranscriptions = totalTranscriptions?.plus(requester.transcriptions.count())
            }

            isBusy = false
        }
    }


    override fun toString(): String = requester.javaClass.simpleName
    override fun hashCode(): Int = requester.hashCode()
    override fun equals(other: Any?): Boolean = requester == other


    /*
    actually future overridden methods
    don't forget to specify which of them your class actually implements during inheriting
    DefinitionRequester, TranslationRequester, ExampleRequester, TranscriptionRequester
     */

    val definitions: List<String>
        get() = if (requester is DefinitionRequester) requester.definitions
        else error("It's not a DefinitionRequester!")

    val translations: List<String>
        get() = if (requester is TranslationRequester) requester.translations
        else error("It's not a TranslationRequester!")

    val examples: List<String>
        get() = if (requester is ExampleRequester) requester.examples
        else error("It's not a ExampleRequester!")

    val transcriptions: List<String>
        get() = if (requester is TranscriptionRequester) requester.transcriptions
        else error("It's not a TranscriptionRequester!")
}
