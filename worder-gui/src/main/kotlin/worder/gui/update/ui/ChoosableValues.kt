/**
 * Stamp was generated by <StampedFile.kt>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <ChoosableValues.kt>
 * Created: <31/07/2020, 04:56:09 PM>
 * Modified: <19/11/2020, 01:43:10 PM>
 * Version: <10>
 */

package worder.gui.update.ui

import javafx.beans.property.Property
import javafx.beans.property.SimpleBooleanProperty
import javafx.beans.property.SimpleObjectProperty
import javafx.beans.property.SimpleStringProperty
import javafx.collections.ListChangeListener
import javafx.collections.ObservableList
import tornadofx.asObservable
import tornadofx.bind
import tornadofx.getValue
import tornadofx.observableListOf
import tornadofx.onChange
import tornadofx.setValue

class ChoosableValues<E>(initValues: Collection<E> = emptyList(), val chooseLimit: Int = Int.MAX_VALUE) {
    val choosables: ObservableList<ChoosableValue>
    val chosenChoosables: ObservableList<ChoosableValue> = observableListOf()

    val values: ObservableList<E> = observableListOf()
    val chosenValues: ObservableList<E> = observableListOf()


    init {
        // TODO("Some UI configuration should be added on Update Tab in order to restrict max count of values")
        choosables = initValues.distinct()
                .map { ChoosableValue(it) }
                .take(10)
                .asObservable()

        values.bind(choosables) { it.value }

        chosenValues.bind(chosenChoosables) { it.value }

        chosenChoosables.apply {
            onChange { change: ListChangeListener.Change<out ChoosableValue> ->
                if (change.next() && change.wasRemoved())
                    forEachIndexed { newChosenIndex, choosable ->
                        choosable.chosenIndex = newChosenIndex
                    }
            }
        }
    }


    fun proposeNewValue(value: E): ChoosableValue? {
        if (values.contains(value))
            return null

        choosables.add(ChoosableValue(value))
        return choosables.last()
    }


    @Suppress("MemberVisibilityCanBePrivate")
    inner class ChoosableValue(
            val value: E
    ) {
        val chosenIndexProperty: Property<Int?> = SimpleObjectProperty()
        var chosenIndex: Int? by chosenIndexProperty

        val isChosenProperty: Property<Boolean> = SimpleBooleanProperty()
        var isChosen: Boolean by isChosenProperty

        val chosenOrdinalProperty: Property<String> = SimpleStringProperty("")
        var chosenOrdinal: String by chosenOrdinalProperty


        init {
            chosenIndexProperty.onChange {
                if (it != null)
                    chosenOrdinal = when (chosenIndex?.plus(1)) {
                        1 -> "1st"
                        2 -> "2nd"
                        3 -> "3rd"
                        else -> "${chosenIndex?.plus(1)}th"
                    }
            }

            isChosenProperty.onChange {
                when {
                    it == true && chosenIndex == null -> {
                        if (chosenChoosables.size == chooseLimit) {
                            isChosen = false
                            throw IllegalStateException("Only $chooseLimit values can be chosen for this values set!")
                        }

                        chosenChoosables.add(this)
                        chosenIndex = chosenChoosables.lastIndex
                    }
                    it == false && chosenIndex != null -> {
                        chosenChoosables.removeAt(chosenIndex!!)
                        chosenOrdinal = ""
                        chosenIndex = null
                    }
                }
            }
        }
    }
}
