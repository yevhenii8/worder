/**
 * Stamp was generated by <generateFileStamps.sh>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <DefaultInsertBatch.kt>
 * Created: <02/07/2020, 11:27:00 PM>
 * Modified: <04/08/2020, 07:11:08 PM>
 * Version: <25>
 */

package worder.gui.insert.model.impl

import javafx.beans.property.ListProperty
import javafx.beans.property.ObjectProperty
import javafx.beans.property.SetProperty
import javafx.beans.property.SimpleListProperty
import javafx.beans.property.SimpleObjectProperty
import javafx.beans.property.SimpleSetProperty
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import tornadofx.getValue
import tornadofx.observableListOf
import tornadofx.setValue
import tornadofx.toObservable
import worder.gui.core.model.BareWord
import worder.gui.database.model.WorderInsertDB
import worder.gui.insert.model.BatchUnit
import worder.gui.insert.model.BatchUnit.BatchUnitStatus
import worder.gui.insert.model.BatchUnit.InvalidWord
import worder.gui.insert.model.InsertBatch
import worder.gui.insert.model.InsertBatch.InsertBatchStatus
import java.io.File

class DefaultInsertBatch private constructor(private val database: WorderInsertDB, files: Collection<File>) : InsertBatch {
    companion object {
        fun createInstance(database: WorderInsertDB, files: Collection<File>): InsertBatch = DefaultInsertBatch(database, files)
    }


    // ALL THE UNITS, SPLIT BY THEIR CURRENT STATUS

    override val readyToCommitUnitsProperty: ListProperty<BatchUnit> = SimpleListProperty(observableListOf())
    override val readyToCommitUnits: MutableList<BatchUnit> by readyToCommitUnitsProperty

    override val actionNeededUnitsProperty: ListProperty<BatchUnit> = SimpleListProperty(observableListOf())
    override val actionNeededUnits: MutableList<BatchUnit> by actionNeededUnitsProperty

    override val excludedUnitsProperty: ListProperty<BatchUnit> = SimpleListProperty(observableListOf())
    override val excludedUnits: MutableList<BatchUnit> by excludedUnitsProperty

    override val committingUnitsProperty: ListProperty<BatchUnit> = SimpleListProperty(observableListOf())
    override val committingUnits: MutableList<BatchUnit> by committingUnitsProperty

    override val committedUnitsProperty: ListProperty<BatchUnit> = SimpleListProperty(observableListOf())
    override val committedUnits: MutableList<BatchUnit> by committedUnitsProperty


    // OTHER MODEL PROPERTIES

    override val statusProperty: ObjectProperty<InsertBatchStatus> = SimpleObjectProperty(InsertBatchStatus.ACTION_NEEDED)
    override var status: InsertBatchStatus by statusProperty

    override val observableStats: SimpleInsertBatchStats = SimpleInsertBatchStats().apply {
        readyToCommitUnitsProperty.bind(this@DefaultInsertBatch.readyToCommitUnitsProperty.sizeProperty())
        actionNeededUnitsProperty.bind(this@DefaultInsertBatch.actionNeededUnitsProperty.sizeProperty())
        excludedUnitsProperty.bind(this@DefaultInsertBatch.excludedUnitsProperty.sizeProperty())
        committedUnitsProperty.bind(this@DefaultInsertBatch.committedUnitsProperty.sizeProperty())
    }


    init {
        require(files.isNotEmpty()) {
            "InsertModel can't be initialized without a file!"
        }

        files.forEach {
            require(it.isFile && it.canRead()) {
                "Please provide correct readable file! passed file: ${it.name}"
            }
        }

        files.forEachIndexed { index, file ->
            val (validWords, invalidWords) = file.readLines()
                    .distinct()
                    .map { it.trim() }
                    .partition { BareWord.wordValidator.invoke(it) }

            DefaultBatchUnit(
                    id = "Unit_$index",
                    source = file.name,
                    validWords = validWords,
                    invalidWords = invalidWords
            )

            observableStats.apply {
                totalValidWords += validWords.size
                totalInvalidWords += invalidWords.size
                generatedUnits++
            }
        }

        observableStats.totalWords = observableStats.totalInvalidWords + observableStats.totalValidWords
    }


    override suspend fun commitAllUnits() {
        coroutineScope {
            ArrayList(readyToCommitUnits).apply {
                forEach { launch { it.commit() } }
            }
        }
    }


    private fun updateModelStatus() {
        status = when {
            committingUnits.isNotEmpty() -> InsertBatchStatus.COMMITTING
            readyToCommitUnits.isNotEmpty() -> InsertBatchStatus.READY_TO_COMMIT
            actionNeededUnits.isNotEmpty() -> InsertBatchStatus.ACTION_NEEDED
            committedUnits.size == observableStats.generatedUnits -> InsertBatchStatus.COMMITTED
            excludedUnits.size == observableStats.generatedUnits -> InsertBatchStatus.FULL_EXCLUDE
            else -> InsertBatchStatus.PARTIALLY_COMMITTED
        }
    }


    private inner class DefaultBatchUnit(
            override val id: String,
            override val source: String,
            validWords: List<String>,
            invalidWords: List<String>
    ) : BatchUnit {
        private var stateController: StateController

        override val statusProperty: ObjectProperty<BatchUnitStatus> = SimpleObjectProperty()
        var status: BatchUnitStatus by statusProperty

        override val validWordsProperty: SetProperty<BareWord> = SimpleSetProperty()
        val validWords: MutableSet<BareWord> by validWordsProperty

        override val invalidWordsProperty: SetProperty<InvalidWord> = SimpleSetProperty()
        val invalidWords: MutableSet<InvalidWord> by invalidWordsProperty


        init {
            validWordsProperty.set(validWords.map { BareWord(it) }.toMutableSet().toObservable())
            invalidWordsProperty.set(invalidWords.map { DefaultInvalidWord(it) }.toMutableSet().toObservable())
            stateController = StateController(BatchUnitStatus.READY_TO_COMMIT)
        }


        override suspend fun commit() = stateController.commit()
        override fun exclude() = stateController.excludeFromCommit()
        override fun include() = stateController.includeInCommit()


        private inner class DefaultInvalidWord(override val value: String) : InvalidWord {
            override fun reject() {
                invalidWords.remove(this)
                observableStats.totalInvalidWords--
                stateController.changeState(BatchUnitStatus.READY_TO_COMMIT)
            }

            override fun substitute(substitution: String): Boolean {
                if (!BareWord.wordValidator.invoke(substitution))
                    return false

                validWords.add(BareWord(substitution))
                invalidWords.remove(this)
                stateController.changeState(BatchUnitStatus.READY_TO_COMMIT)

                observableStats.apply {
                    totalInvalidWords--
                    totalValidWords++
                }

                return true
            }
        }

        private inner class StateController(initUnitStatus: BatchUnitStatus) {
            private var unitState: UnitState = pickUpState(initUnitStatus)


            init {
                status = initUnitStatus
                unitState.onAttach()
                updateModelStatus()
            }


            suspend fun commit() = unitState.commit()
            fun excludeFromCommit() = unitState.excludeFromCommit()
            fun includeInCommit() = unitState.includeInCommit()


            fun changeState(newUnitStatus: BatchUnitStatus) {
                unitState.onDetach()
                unitState = pickUpState(newUnitStatus)
                status = newUnitStatus
                unitState.onAttach()
                updateModelStatus()
            }


            private fun pickUpState(status: BatchUnitStatus): UnitState = when (status) {
                BatchUnitStatus.READY_TO_COMMIT -> ReadyToCommitState()
                BatchUnitStatus.ACTION_NEEDED -> ActionNeededState()
                BatchUnitStatus.EXCLUDED_FROM_COMMIT -> ExcludedFromCommitState()
                BatchUnitStatus.COMMITTING -> CommittingState()
                BatchUnitStatus.COMMITTED -> CommittedState()
            }


            private abstract inner class UnitState {
                open suspend fun commit() {
                    error("You can't commit unit with status: ${this@DefaultBatchUnit.status}")
                }

                open fun excludeFromCommit() {
                    error("You can't exclude unit with status: ${this@DefaultBatchUnit.status}")
                }

                open fun includeInCommit() {
                    error("You can't include unit with status: ${this@DefaultBatchUnit.status}")
                }


                open fun onAttach() {}

                open fun onDetach() {}
            }

            private inner class ReadyToCommitState : UnitState() {
                override suspend fun commit() {
                    withContext(Dispatchers.Main) {
                        changeState(BatchUnitStatus.COMMITTING)
                    }

                    val (reset, inserted) = database.resolveWords(validWords)
                            .entries
                            .partition { it.value == WorderInsertDB.ResolveRes.RESET }

                    withContext(Dispatchers.Main) {
                        observableStats.apply {
                            this.reset += reset.size
                            this.inserted += inserted.size
                            this.totalProcessed = this.reset + this.inserted
                        }

                        changeState(BatchUnitStatus.COMMITTED)
                    }
                }

                override fun excludeFromCommit() {
                    changeState(BatchUnitStatus.EXCLUDED_FROM_COMMIT)
                }

                override fun onAttach() {
                    if (invalidWords.isNotEmpty())
                        changeState(BatchUnitStatus.ACTION_NEEDED)
                    else
                        readyToCommitUnits.add(this@DefaultBatchUnit)
                }

                override fun onDetach() {
                    readyToCommitUnits.remove(this@DefaultBatchUnit)
                }
            }

            private inner class ActionNeededState : UnitState() {
                override fun excludeFromCommit() {
                    changeState(BatchUnitStatus.EXCLUDED_FROM_COMMIT)
                }

                override fun onAttach() {
                    actionNeededUnits.add(this@DefaultBatchUnit)
                }

                override fun onDetach() {
                    actionNeededUnits.remove(this@DefaultBatchUnit)
                }
            }

            private inner class ExcludedFromCommitState : UnitState() {
                override fun includeInCommit() {
                    changeState(BatchUnitStatus.READY_TO_COMMIT)
                }

                override fun onAttach() {
                    excludedUnits.add(this@DefaultBatchUnit)
                }

                override fun onDetach() {
                    excludedUnits.remove(this@DefaultBatchUnit)
                }
            }

            private inner class CommittingState : UnitState() {
                override fun onAttach() {
                    committingUnits.add(this@DefaultBatchUnit)
                }

                override fun onDetach() {
                    committingUnits.remove(this@DefaultBatchUnit)
                }
            }

            private inner class CommittedState : UnitState() {
                override fun onAttach() {
                    committedUnits.add(this@DefaultBatchUnit)
                }
            }
        }
    }
}
