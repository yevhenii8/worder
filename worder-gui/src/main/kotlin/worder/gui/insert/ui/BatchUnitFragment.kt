/**
 * Stamp was generated by <generateFileStamps.sh>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <BatchUnitFragment.kt>
 * Created: <02/07/2020, 11:27:00 PM>
 * Modified: <18/11/2020, 06:15:03 PM>
 * Version: <104>
 */

package worder.gui.insert.ui

import javafx.beans.property.SimpleBooleanProperty
import javafx.beans.value.ObservableValue
import javafx.geometry.Pos
import javafx.scene.layout.Priority
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import tornadofx.Fragment
import tornadofx.addClass
import tornadofx.bindChildren
import tornadofx.button
import tornadofx.enableWhen
import tornadofx.field
import tornadofx.fieldset
import tornadofx.fold
import tornadofx.form
import tornadofx.hbox
import tornadofx.hgrow
import tornadofx.imageview
import tornadofx.label
import tornadofx.onChange
import tornadofx.paddingTop
import tornadofx.removeWhen
import tornadofx.squeezebox
import tornadofx.textfield
import tornadofx.useMaxWidth
import tornadofx.usePrefSize
import tornadofx.vbox
import worder.gui.core.styles.WorderCustomStyles
import worder.gui.core.worderStatusLabel
import worder.gui.insert.model.BatchUnit

class BatchUnitFragment : Fragment() {
    companion object {
        const val batchUnitWidth: Double = 460.0
    }


    private val unit: BatchUnit by param()


    override val root = vbox {
        prefWidth = batchUnitWidth
        addClass(WorderCustomStyles.worderBlock)
        hbox(spacing = 20, alignment = Pos.CENTER) {
            imageview("/icons/blue-document_64x64.png")
            vbox(alignment = Pos.BASELINE_RIGHT, spacing = 4) {
                hgrow = Priority.ALWAYS
                label("ID:")
                label("Status:")
                label("Source:")
                label("Valid Words:")
                label("Invalid Words:")
            }
            vbox(alignment = Pos.BASELINE_LEFT, spacing = 4) {
                hgrow = Priority.ALWAYS
                label(unit.id)
                worderStatusLabel(unit.statusProperty)
                label(unit.source)
                label(unit.validWordsProperty.sizeProperty())
                label(unit.invalidWordsProperty.sizeProperty())
            }
            vbox(spacing = 5) {
                usePrefSize = true
                button("Commit") {
                    enableWhen {
                        BatchUnit.BatchUnitAction.COMMIT.getListener()
                    }
                    setOnAction {
                        CoroutineScope(Dispatchers.Default).launch { unit.commit() }
                    }
                }
                button("Exclude") {
                    enableWhen {
                        BatchUnit.BatchUnitAction.EXCLUDE.getListener()
                    }
                    setOnAction {
                        unit.exclude()
                    }
                }
                button("Include") {
                    enableWhen {
                        BatchUnit.BatchUnitAction.INCLUDE.getListener()
                    }
                    setOnAction {
                        unit.include()
                    }
                }
            }
        }
        if (unit.invalidWordsProperty.isNotEmpty()) {
            squeezebox {
                paddingTop = 15
                removeWhen(unit.invalidWordsProperty.sizeProperty().isEqualTo(0))
                fold("List of invalid words") {
                    form().fieldset().bindChildren(unit.invalidWordsProperty) { invalidWord ->
                        field(invalidWord.value) {
                            val textFiled = textfield(invalidWord.value)
                            button("OK") {
                                setOnAction {
                                    if (!invalidWord.substitute(textFiled.text))
                                        tornadofx.error("Validation error", "Please, type a valid word!")
                                }
                            }
                            button("X") {
                                setOnAction {
                                    invalidWord.reject()
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    init {
        with(unit.statusProperty) {
            if (value == BatchUnit.BatchUnitStatus.COMMITTED)
                root.isDisable = true

            onChange { status ->
                if (status == BatchUnit.BatchUnitStatus.COMMITTED)
                    root.isDisable = true
            }
        }
    }


    private fun BatchUnit.BatchUnitAction.getListener(): ObservableValue<Boolean> {
        val listener = SimpleBooleanProperty(unit.statusProperty.value.availableActions.contains(this))
        unit.statusProperty.onChange {
            listener.value = it!!.availableActions.contains(this)
        }
        return listener
    }
}
