/**
 * Stamp was generated by <StampedFile.kt>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <ChoosablesTableFragment.kt>
 * Created: <29/07/2020, 07:38:48 PM>
 * Modified: <30/07/2020, 11:36:44 PM>
 * Version: <50>
 */

package worder.update.ui

import javafx.beans.property.Property
import javafx.beans.property.SimpleObjectProperty
import javafx.beans.property.SimpleStringProperty
import javafx.collections.ListChangeListener
import javafx.collections.ObservableList
import javafx.geometry.Orientation
import javafx.geometry.VPos
import javafx.scene.control.Button
import javafx.scene.control.CheckBox
import javafx.scene.control.Label
import javafx.scene.control.Separator
import javafx.scene.control.TextField
import javafx.scene.input.KeyCode
import javafx.scene.layout.GridPane
import javafx.scene.paint.Color
import tornadofx.Fragment
import tornadofx.bind
import tornadofx.box
import tornadofx.constraintsForColumn
import tornadofx.enableWhen
import tornadofx.getValue
import tornadofx.gridpane
import tornadofx.observableListOf
import tornadofx.onChange
import tornadofx.px
import tornadofx.setValue
import tornadofx.sizeProperty
import tornadofx.style
import tornadofx.usePrefWidth
import tornadofx.warning
import worder.tornadofx.bindIndexed

class ChoosablesTableFragment : Fragment() {
    private val allValues: ObservableList<String> by param()
    private val chosenValues: ObservableList<Int> by param()
    private val chooseLimit: Int by param()

    private val choosables: ObservableList<Choosable> = observableListOf()
    private val chosen: ObservableList<Choosable> = observableListOf()


    init {
        choosables.apply {
            bindIndexed(allValues) { index, value ->
                Choosable(index, value)
            }

            onChange { change: ListChangeListener.Change<out Choosable> ->
                if (change.next() && change.wasAdded()) {
                    root.apply {
                        children.removeIf {
                            GridPane.getRowIndex(it) == (rowCount - 1)
                        }

                        change.addedSubList.forEach { newChoosable ->
                            putChoosable(newChoosable)
                        }

                        appendCustomValueField()
                    }
                }
            }
        }

        chosen.apply {
            bindIndexed(chosenValues) { chosenIndex, originalIndex ->
                choosables[originalIndex].also {
                    it.isChosen = true
                    it.chosenOrdinal = when (chosenIndex + 1) {
                        1 -> "1st"
                        2 -> "2nd"
                        3 -> "3rd"
                        else -> "${chosenIndex + 1}th"
                    }
                }
            }

            onChange { change: ListChangeListener.Change<out Choosable> ->
                if (change.next() && change.wasRemoved()) {
                    change.removed.forEach {
                        it.chosenOrdinal = ""
                        it.isChosen = false
                    }

                    forEachIndexed { chosenIndex, choosable ->
                        choosable.chosenOrdinal = when (chosenIndex + 1) {
                            1 -> "1st"
                            2 -> "2nd"
                            3 -> "3rd"
                            else -> "${chosenIndex + 1}th"
                        }
                    }
                }
            }
        }
    }


    override val root: GridPane = gridpane {
        hgap = 5.0
        vgap = 5.0

        choosables.forEach {
            putChoosable(it)
        }

        add(Separator(Orientation.VERTICAL), 1, 0, 1, GridPane.REMAINING)
        constraintsForColumn(0).minWidth = 40.0
        appendCustomValueField()
    }


    private fun GridPane.putChoosable(choosable: Choosable) {
        Label().apply {
            bind(choosable.chosenOrdinalProperty)
            add(this, 0, choosable.index, 1, 1)
            GridPane.setValignment(this, VPos.TOP)
        }

        val checkBox = CheckBox().apply {
            selectedProperty().bindBidirectional(choosable.isChosenProperty)
            enableWhen(chosenValues.sizeProperty.lessThan(chooseLimit).or(selectedProperty()))
            add(this, 2, choosable.index, 1, 1)
            GridPane.setValignment(this, VPos.TOP)
        }

        Label("${choosable.index + 1})").apply {
            usePrefWidth = true
            disableProperty().bind(checkBox.disableProperty())
            add(this, 3, choosable.index, 1, 1)
            GridPane.setValignment(this, VPos.TOP)
        }

        Label(choosable.value).apply {
            isWrapText = true
            disableProperty().bind(checkBox.disableProperty())
            add(this, 4, choosable.index, 1, 1)
        }
    }

    private fun GridPane.appendCustomValueField() {
        val newRowIndex = rowCount
        val textField = TextField()

        val button = Button("+").apply {
            style {
                padding = box(3.px)
            }

            setOnAction {
                val input = textField.text.also {
                    if (it.isBlank()) {
                        warning("Please type something in the field!")
                        return@setOnAction
                    }
                }

                allValues.add(input)
                chosenValues.add(allValues.lastIndex)
                textField.text = null
            }

            enableWhen(chosenValues.sizeProperty.lessThan(chooseLimit))
            add(this, 2, newRowIndex, 1, 1)
        }

        Label("${newRowIndex + 1})").apply {
            usePrefWidth = true
            add(this, 3, newRowIndex, 1, 1)
            disableProperty().bind(button.disableProperty())
        }

        textField.apply {
            promptText = "custom value"

            style {
                backgroundColor += Color.TRANSPARENT
                padding = box(0.px)
            }

            setOnKeyPressed {
                if (it.code == KeyCode.ENTER) {
                    button.onAction.handle(null)
                }
            }

            disableProperty().bind(button.disableProperty())
            add(this, 4, newRowIndex, 1, 1)
        }
    }


    private inner class Choosable(val index: Int, val value: String) {
        val isChosenProperty: Property<Boolean> = SimpleObjectProperty(false)
        var isChosen: Boolean by isChosenProperty

        val chosenOrdinalProperty: Property<String> = SimpleStringProperty()
        var chosenOrdinal: String by chosenOrdinalProperty


        init {
            isChosenProperty.onChange {
                when {
                    it == true && !chosenValues.contains(index) -> chosenValues.add(index)
                    it == false -> chosenValues.remove(index)
                }
            }
        }
    }
}
