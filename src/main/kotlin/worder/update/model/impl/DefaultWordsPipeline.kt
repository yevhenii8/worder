/**
 * Stamp was generated by <StampedFile.kt>
 * Last time was modified by <StampedFile.kt>
 *
 * Name: <DefaultWordsPipeline.kt>
 * Created: <20/07/2020, 11:22:35 PM>
 * Modified: <25/07/2020, 10:07:18 PM>
 * Version: <45>
 */

package worder.update.model.impl

import javafx.beans.property.ListProperty
import javafx.beans.property.Property
import javafx.beans.property.SimpleListProperty
import javafx.beans.property.SimpleObjectProperty
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import tornadofx.getValue
import tornadofx.observableListOf
import tornadofx.onChangeOnce
import tornadofx.setValue
import worder.database.model.DatabaseWord
import worder.database.model.UpdatedWord
import worder.database.model.WorderUpdateDB
import worder.update.model.DefinitionRequester
import worder.update.model.ExampleRequester
import worder.update.model.Requester
import worder.update.model.TranscriptionRequester
import worder.update.model.TranslationRequester
import worder.update.model.WordBlock
import worder.update.model.WordsPipeline

class DefaultWordsPipeline private constructor(
        val database: WorderUpdateDB,
        override val usedRequesters: List<Requester>,
        override var selectOrder: WorderUpdateDB.SelectOrder
) : WordsPipeline {
    companion object {
        fun createInstance(
                database: WorderUpdateDB,
                usedRequesters: List<Requester>,
                selectOrder: WorderUpdateDB.SelectOrder
        ): WordsPipeline = DefaultWordsPipeline(database, usedRequesters, selectOrder)
    }


    private val definitionRequesters = mutableSetOf<DefinitionRequester>()
    private val exampleRequesters = mutableSetOf<ExampleRequester>()
    private val translationRequesters = mutableSetOf<TranslationRequester>()
    private val transcriptionRequesters = mutableSetOf<TranscriptionRequester>()

    override val pipelineProperty: ListProperty<WordBlock> = SimpleListProperty(observableListOf())
    override val pipeline: MutableList<WordBlock> by pipelineProperty

    override val isEmptyProperty: Property<Boolean> = SimpleObjectProperty<Boolean>(false)
    override var isEmpty: Boolean by isEmptyProperty

    private lateinit var backgroundJob: Job
    private lateinit var current: WordBlock
    private var readyToCommit: WordBlock? = null
    private var next: WordBlock? = null
    private var blocksCounter = 1


    init {
        usedRequesters.forEach {
            if (it is DefinitionRequester)
                definitionRequesters += it
            if (it is TranslationRequester)
                translationRequesters += it
            if (it is ExampleRequester)
                exampleRequesters += it
            if (it is TranscriptionRequester)
                transcriptionRequesters += it
        }

        runBlocking {
            composeNext()?.let {
                pipeline.add(it)
                current = it
                backgroundJob = CoroutineScope(Dispatchers.Default).launch {
                    next = composeNext()
                }
            }
        }
    }


    private suspend fun composeNext(): WordBlock? {
        if (!database.hasNextWord()) {
            isEmpty = true
            return null
        }

        val dbWord = database.getNextWord(selectOrder)
        usedRequesters.forEach { it.requestWord(dbWord) }

        val definitions = definitionRequesters.flatMap { it.definitions }.distinct()
        val examples = (exampleRequesters.flatMap { it.examples } + dbWord.examples).distinct()
        val translations = (translationRequesters.flatMap { it.translations } + dbWord.translations).distinct()
        val transcriptions = (listOf(dbWord.transcription) + transcriptionRequesters.flatMap { it.transcriptions }).filterNotNull().distinct()

        val newBlock = DefaultWordBlock(
                id = "${blocksCounter++}",
                originalWord = dbWord,
                definitions = definitions,
                examples = examples,
                translations = translations,
                transcriptions = transcriptions
        )

        newBlock.apply {
            statusProperty.onChangeOnce {
                if (isEmpty) {
                    backgroundJob = CoroutineScope(Dispatchers.Default).launch {
                        readyToCommit?.commit()
                        current.commit()
                    }
                    return@onChangeOnce
                }

                if (current == next || next == null)
                    runBlocking {
                        backgroundJob.join()
                    }

                pipeline.add(next!!)

                backgroundJob = CoroutineScope(Dispatchers.Default).launch {
                    readyToCommit?.commit()
                    readyToCommit = current
                    current = next!!
                    next = composeNext()
                }
            }
        }

        return newBlock
    }


    private inner class DefaultWordBlock(
            override val id: String,
            override val originalWord: DatabaseWord,
            override val definitions: List<String>,
            override val examples: List<String>,
            override val translations: List<String>,
            override val transcriptions: List<String>
    ) : WordBlock {
        override val statusProperty: Property<WordBlock.WordBlockStatus> = SimpleObjectProperty(WordBlock.WordBlockStatus.RESOLUTION_NEEDED)
        override var status: WordBlock.WordBlockStatus by statusProperty

        override val resolutionProperty: Property<WordBlock.WordBlockResolution> = SimpleObjectProperty(WordBlock.WordBlockResolution.NO_RESOLUTION)
        override var resolution: WordBlock.WordBlockResolution by resolutionProperty

        private var updatedWord: UpdatedWord? = null


        override suspend fun commit() {
            if (status != WordBlock.WordBlockStatus.READY_TO_COMMIT)
                error("You can't commit block with status: $status")

            when (resolution) {
                WordBlock.WordBlockResolution.SKIPPED -> database.setAsSkipped(originalWord)
                WordBlock.WordBlockResolution.REMOVED -> database.removeWord(originalWord)
                WordBlock.WordBlockResolution.LEARNED -> database.setAsLearned(originalWord)
                WordBlock.WordBlockResolution.UPDATED -> database.updateWord(updatedWord!!)
                WordBlock.WordBlockResolution.NO_RESOLUTION -> error("You can't commit block with NO_RESOLUTION!")
            }

            MainScope().launch {
                status = WordBlock.WordBlockStatus.COMMITTED
            }
        }

        override fun update(primaryDefinition: String, secondaryDefinition: String?, transcription: String?, examples: List<String>) {
            if (status == WordBlock.WordBlockStatus.COMMITTED)
                error("You can't update block with status: $status")

            updatedWord = UpdatedWord(
                    name = originalWord.name,
                    transcription = transcription,
                    primaryDefinition = primaryDefinition,
                    secondaryDefinition = secondaryDefinition,
                    examples = examples
            )

            resolution = WordBlock.WordBlockResolution.UPDATED
            status = WordBlock.WordBlockStatus.READY_TO_COMMIT
        }

        override fun remove() {
            if (status == WordBlock.WordBlockStatus.COMMITTED)
                error("You can't remove block with status: $status")

            resolution = WordBlock.WordBlockResolution.REMOVED
            status = WordBlock.WordBlockStatus.READY_TO_COMMIT
        }

        override fun learn() {
            if (status == WordBlock.WordBlockStatus.COMMITTED)
                error("You can't learn block with status: $status")

            resolution = WordBlock.WordBlockResolution.LEARNED
            status = WordBlock.WordBlockStatus.READY_TO_COMMIT
        }

        override fun skip() {
            if (status == WordBlock.WordBlockStatus.COMMITTED)
                error("You can't skip block with status: $status")

            resolution = WordBlock.WordBlockResolution.SKIPPED
            status = WordBlock.WordBlockStatus.READY_TO_COMMIT
        }
    }
}
